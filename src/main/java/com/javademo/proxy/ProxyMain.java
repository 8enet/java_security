package com.javademo.proxy;

import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponse;
import net.lightbody.bmp.BrowserMobProxy;
import net.lightbody.bmp.BrowserMobProxyServer;
import net.lightbody.bmp.filters.RequestFilter;
import net.lightbody.bmp.filters.ResponseFilter;
import net.lightbody.bmp.mitm.CertificateAndKeySource;
import net.lightbody.bmp.mitm.CertificateInfo;
import net.lightbody.bmp.mitm.PemFileCertificateSource;
import net.lightbody.bmp.mitm.RootCertificateGenerator;
import net.lightbody.bmp.mitm.manager.ImpersonatingMitmManager;
import net.lightbody.bmp.util.HttpMessageContents;
import net.lightbody.bmp.util.HttpMessageInfo;
import org.littleshoot.proxy.ChainedProxy;
import org.littleshoot.proxy.ChainedProxyAdapter;
import org.littleshoot.proxy.ChainedProxyManager;
import org.littleshoot.proxy.HttpProxyServerBootstrap;

import java.io.File;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.net.UnknownHostException;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * 简单http/https 代理服务器
 * Created by zl on 16/2/26.
 */
public class ProxyMain {

    /**
     * 查看证书信息 openssl x509 -in /Users/zl/certificate.cer -text
     */

    static final String X509_CERT="/Users/zl/certificate.cer";
    static final String PRIVATE_KEY="/Users/zl/private-key.pem";
    static final String PASSWORD="asdf!@321";


    static final int PROXY_PORT=8099;

    /**
     * 生成根证书
     */
    private static void rootCertificateGenerator(){
        String hostname;
        try {
            hostname = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            hostname = "localhost";
        }

        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss zzz");

        String currentDateTime = dateFormat.format(new Date());

        String defaultCN = "Generated CA (" + hostname + ") " + currentDateTime;

        // CN fields can only be 64 characters
        String commonName= defaultCN.length() <= 64 ? defaultCN : defaultCN.substring(0, 63);


        CertificateInfo certificateInfo = new CertificateInfo()
                .commonName(commonName)
                .organization("CA generated by Proxy")
                .notBefore(new Date(System.currentTimeMillis()))
                .notAfter(new Date(System.currentTimeMillis() + 365L * 24L * 60L * 60L* 1000L));
        //证书有效期一年

        RootCertificateGenerator rootCertificateGenerator = RootCertificateGenerator.builder()
                .certificateInfo(certificateInfo)
                .build();

        rootCertificateGenerator.saveRootCertificateAsPemFile(new File(X509_CERT));
        rootCertificateGenerator.savePrivateKeyAsPemFile(new File(PRIVATE_KEY), PASSWORD);
    }

    public static void main(String[] args) throws URISyntaxException {

        //先生成证书，导入certificate.cer 文件到系统或浏览器，只要生成一次并导入即可
        //rootCertificateGenerator();

//        File cert= new File(ClassLoader.getSystemResource("certificate.cer").toURI());
//        File pem=new File(ClassLoader.getSystemResource("private-key.pem").toURI());
//
//        //然后将证书加载到
//        CertificateAndKeySource existingCertificateSource=new PemFileCertificateSource(cert,pem, PASSWORD);
//
//        ImpersonatingMitmManager mitmManager = ImpersonatingMitmManager.builder()
//                .rootCertificateSource(existingCertificateSource)
//                .build();


        BrowserMobProxyServer proxy = new BrowserMobProxyServer(PROXY_PORT);

        //proxy.setMitmManager(mitmManager);

        InetSocketAddress upstreamProxy = new InetSocketAddress("218.75.207.110",8090);
        //upstreamProxy = InetSocketAddress.createUnresolved("127.0.0.1",8888);

        final InetSocketAddress address=upstreamProxy;

        final List<InetSocketAddress> addressList=new ArrayList<>();
        //addressList.add(new InetSocketAddress("222.88.142.51",8000));
        //addressList.add(new InetSocketAddress("218.75.207.110",8090));
        addressList.add(new InetSocketAddress("103.227.128.243",3128));
        addressList.add(new InetSocketAddress("125.39.67.194",3128));


//        proxy.setChainedProxyManager(new ChainedProxyManager() {
//            @Override
//            public void lookupChainedProxies(HttpRequest httpRequest, Queue<ChainedProxy> chainedProxies) {
//
//                chainedProxies.add(new ChainedProxyAdapter(){
//                    @Override
//                    public InetSocketAddress getChainedProxyAddress() {
//                        System.out.println("---"+address);
//                        return address;
//                    }
//                });
//
//
////                for (InetSocketAddress address1:addressList){
////                    chainedProxies.add(new ChainedProxyAdapter(){
////                        @Override
////                        public InetSocketAddress getChainedProxyAddress() {
////                            System.out.println("---"+address1);
////                            return address1;
////                        }
////                    });
////                }
//
//                //chainedProxies.add(ChainedProxyAdapter.FALLBACK_TO_DIRECT_CONNECTION);
//
//                System.out.println("lookupChainedProxies " + httpRequest.getUri() + "  " + chainedProxies);
//
//            }
//        });


//        proxy.addRequestFilter(new RequestFilter() {
//            @Override
//            public HttpResponse filterRequest(HttpRequest request, HttpMessageContents contents, HttpMessageInfo messageInfo) {
//
//
//                final HttpHeaders headers = request.headers();
//                if(headers != null){
//                    final String accept = headers.get("Accept");
//                    if(accept != null && (accept.contains("application") )){
//                        StringBuilder sb=new StringBuilder();
//
//                        sb.append(request.getUri());
//                        sb.append("\n");
//                        final List<Map.Entry<String, String>> entries = headers.entries();
//                        for (Map.Entry<String, String> entry:entries){
//                            System.out.println(entry.getKey()+":"+entry.getValue());
//                            sb.append(entry.getKey()).append(':').append(entry.getValue()).append('\n');
//                        }
//                        //RedisQueueManager.getInstance().publish(sb);
//                    }
//                }
//
//                return null;
//            }
//        });

        proxy.addRequestFilter(new RequestFilter() {
            @Override
            public HttpResponse filterRequest(HttpRequest request, HttpMessageContents contents, HttpMessageInfo messageInfo) {


                final HttpHeaders headers = request.headers();
                if(headers != null){
                    headers.remove("Cookie");

                }
                System.out.println(request.getClass());

                return null;
            }
        });

        proxy.addResponseFilter(new ResponseFilter() {
            @Override
            public void filterResponse(HttpResponse response, HttpMessageContents contents, HttpMessageInfo messageInfo) {

                //System.out.println(messageInfo.getOriginalUrl());

                final HttpHeaders headers = response.headers();

                if(contents.isText()){

                    if(headers != null){
                        final List<Map.Entry<String, String>> entries = headers.entries();
                        for (Map.Entry<String, String> entry:entries){
                            System.out.println(entry.getKey()+":"+entry.getValue());
                        }
                    }
                    //System.out.println(contents.getTextContents());
                }
            }
        });

        //二级代理
        //proxy.setChainedProxy(upstreamProxy);


        proxy.start();

    }





}
